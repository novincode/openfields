#!/usr/bin/env tsx

import { writeFileSync, mkdirSync, readFileSync } from "fs";
import { globSync } from "glob";
import { codeToHtml } from "shiki";
import * as crypto from "crypto";

interface CodeBlockEntry {
	id: string;
	code: string;
	lang: string;
	lightHtml: string;
	darkHtml: string;
	filePath: string;
	manualId?: string;
}

// Configuration
const SCAN_PATTERN = "src/app/(docs)/**/*.tsx";
const OUTPUT_DIR = "src/generated/codes";
const OUTPUT_FILE = `${OUTPUT_DIR}/index.ts`;

const DEBUG = process.argv.includes("--debug") || process.env.DEBUG === "true";

function debug(...args: unknown[]) {
	if (DEBUG) {
		console.log("üêõ", ...args);
	}
}

/**
 * Normalize code for consistent matching
 */
function normalizeCode(code: string): string {
	return code
		.replace(/\r\n/g, "\n")
		.replace(/\\`/g, "`")
		.replace(/\\\$/g, "$")
		.replace(/\\\\/g, "\\")
		.split("\n")
		.map((line) => line.trimEnd())
		.join("\n")
		.trim();
}

// Extract code blocks from file content
function extractCodeBlocks(
	content: string,
	filePath: string
): Array<{ code: string; lang: string; manualId?: string }> {
	const codeBlocks: Array<{ code: string; lang: string; manualId?: string }> = [];

	const components = content.split("<CodeBlockRegistry");

	for (let i = 1; i < components.length; i++) {
		const component = components[i];

		const nextComponentIndex = component.indexOf("<CodeBlockRegistry");
		const searchSpace = nextComponentIndex > 0 ? component.substring(0, nextComponentIndex) : component;
		const endIndex = searchSpace.lastIndexOf("/>");
		if (endIndex === -1) continue;

		const componentContent = component.substring(0, endIndex);

		const codeMatch = componentContent.match(/code=\{`([\s\S]+?)`\}/);
		const langMatch = componentContent.match(/lang="([^"]+)"/);

		let idMatch: RegExpMatchArray | null = null;
		if (codeMatch && codeMatch.index !== undefined) {
			const propsBeforeCode = componentContent.substring(0, codeMatch.index);
			const propsAfterCode = componentContent.substring(codeMatch.index + codeMatch[0].length);

			idMatch =
				propsBeforeCode.match(/\sid=\{`([^`]+)`\}/) ||
				propsBeforeCode.match(/\sid="([^"]+)"/) ||
				propsAfterCode.match(/\sid=\{`([^`]+)`\}/) ||
				propsAfterCode.match(/\sid="([^"]+)"/);

			debug(`ID Match: ${idMatch ? idMatch[1] : "none"}`);
		}

		if (codeMatch && langMatch) {
			const manualId = idMatch ? idMatch[1] : undefined;
			const code = codeMatch[1];
			const lang = langMatch[1];

			const normalizedCode = normalizeCode(code);
			codeBlocks.push({ code: normalizedCode, lang, manualId });
			debug(`Found block in ${filePath}: ${lang}, length: ${normalizedCode.length}`);
		}
	}

	return codeBlocks;
}

// Generate unique hash-based ID
function generateId(code: string, lang: string): string {
	const hash = crypto.createHash("sha256").update(code + lang).digest("hex").substring(0, 12);
	return `code_${hash}`;
}

async function generate() {
	console.log("üîç Scanning for code blocks...\n");

	const files = globSync(SCAN_PATTERN);
	const codeBlockMap = new Map<string, CodeBlockEntry>();

	for (const file of files) {
		const content = readFileSync(file, "utf-8");
		const blocks = extractCodeBlocks(content, file);

		for (const block of blocks) {
			const id = block.manualId || generateId(block.code, block.lang);

			debug(`Processing block with ID: ${id}, manual: ${!!block.manualId}`);

			const normalizedBlockCode = normalizeCode(block.code);
			const existingEntry = Array.from(codeBlockMap.values()).find((entry) => {
				const normalizedEntryCode = normalizeCode(entry.code);
				return normalizedEntryCode === normalizedBlockCode && entry.lang === block.lang;
			});

			if (existingEntry) {
				if (!block.manualId || existingEntry.manualId === block.manualId) {
					console.log(`  ‚ö†Ô∏è  Skipping duplicate: ${id} (already as ${existingEntry.id})`);
					continue;
				}
			}

			if (!codeBlockMap.has(id)) {
				const label = block.manualId ? "[MANUAL ID]" : "";
				console.log(`  Found: ${id} (${block.lang}) ${label} in ${file}`);

				const lightHtml = await codeToHtml(block.code, {
					lang: block.lang as Parameters<typeof codeToHtml>[1]["lang"],
					theme: "github-light",
				});

				const darkHtml = await codeToHtml(block.code, {
					lang: block.lang as Parameters<typeof codeToHtml>[1]["lang"],
					theme: "github-dark",
				});

				codeBlockMap.set(id, {
					id,
					code: block.code,
					lang: block.lang,
					lightHtml,
					darkHtml,
					filePath: file,
					manualId: block.manualId,
				});
			}
		}
	}

	const entries = Array.from(codeBlockMap.values());

	const registryContent = `// ‚ö†Ô∏è This file is auto-generated by scripts/generate-codeblocks.ts
// Do not edit manually. Run 'pnpm run generate:codes' to regenerate.
// Generated on: ${new Date().toISOString()}

export interface CodeBlockData {
  id: string
  code: string
  lang: string
  lightHtml: string
  darkHtml: string
}

export const codeBlockRegistry: Record<string, CodeBlockData> = {
${entries
	.map(
		(entry) => `  '${entry.id}': {
    id: '${entry.id}',
    code: ${JSON.stringify(entry.code)},
    lang: '${entry.lang}',
    lightHtml: ${JSON.stringify(entry.lightHtml)},
    darkHtml: ${JSON.stringify(entry.darkHtml)},
  }`
	)
	.join(",\n")}
}

export function getCodeBlock(id: string): CodeBlockData | undefined {
  return codeBlockRegistry[id]
}

function normalizeCode(code: string): string {
  return code
    .replace(/\\r\\n/g, '\\n')
    .replace(/\\\\\`/g, '\`')
    .replace(/\\\\\\\$/g, '$')
    .replace(/\\\\\\\\/g, '\\\\')
    .split('\\n')
    .map(line => line.trimEnd())
    .join('\\n')
    .trim()
}

export function getCodeBlockByContent(code: string, lang: string, manualId?: string): CodeBlockData | undefined {
  if (manualId && codeBlockRegistry[manualId]) {
    return codeBlockRegistry[manualId]
  }
  
  const normalizedInput = normalizeCode(code)
  const entries = Object.values(codeBlockRegistry)
  
  return entries.find(entry => {
    const normalizedEntry = normalizeCode(entry.code)
    return normalizedEntry === normalizedInput && entry.lang === lang
  })
}
`;

	mkdirSync(OUTPUT_DIR, { recursive: true });
	writeFileSync(OUTPUT_FILE, registryContent, "utf-8");

	console.log(`\n‚úÖ Generated ${entries.length} code blocks`);
	console.log(`üìù Registry created at: ${OUTPUT_FILE}\n`);
}

generate().catch((err) => {
	console.error("‚ùå Generation failed:", err);
	process.exit(1);
});
